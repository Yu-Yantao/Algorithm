# 滑动窗口

## 1.介绍

滑动窗口是双指针问题的一种，通常用于解决**子数组**、**子串**、**字符串**等问题。滑动窗口的核心是窗口中的内容，而双指针的核心是两个指针。

通常情况下，我们在处理子数组/子串等问题时，会按照如下处理方式

```python
for left in range(len(nums)):
    for right in range(left, len(nums)):
# nums[left, right] 是一个子数组

```

这样处理的方式，时间复杂度是O(n^2)，显然，这种处理方式太慢了。

滑动窗口的核心思想是，我们用一个窗口来维护一个子数组/子串，窗口的左边界和右边界分别是i和j，窗口的右边界向右移动，当满足某种条件时，窗口的左边界向右
移动，直到窗口满足某种条件。代码如下:

```python
left, right = 0, 0
while right < len(nums):
    # 增大窗口
    window.add(nums[right])
    right += 1
    # 判断是否要收缩
    while window_needs_shrink:
        # 缩小窗口
        window.remove(nums[left])
        left += 1

```

在这段代码中，while循环中嵌套了while循环，但是，它的时间复杂度是O(n)，因为left和right没有进行回退，每个元素只访问一次(
上述的暴力求解代码中，每次外层循环开始时，right从left + 1开始，增长到len(nums)，会进行回退，所以时间复杂度是O(n^2))。

当窗口满足条件后，在缩小窗口时，缩小后的窗口也有可能会不满足条件，例如在**76.最小覆盖串中**，当窗口满足条件时，进行缩小窗口，会记录一个覆盖串的长度。
这个长度，即是我们需要的最短覆盖子串的长度。在缩小窗口时，记录了这个长度，即使在推出循环时，窗口中的数据不满足条件也无所谓

> 需要注意的是，滑动窗口并**不能枚举**所有的子数组/子串，但是，它却可以枚举**所有满足某种条件**的子数组/子串。

## 2 有意思的题目

- 76.最小覆盖子串
- 424.替换后的最长重复字符
- 713.乘积小于 K 的子数组
- 1358.包含所有三种字符的子字符串数目

## 3.总结

- 当窗口大小固定时，可以省去某一边边界的处理，例如在**子数组最大平均数 I**中，窗口大小为K，可以枚举右边界，左边界为right - K。
- 滑动窗口主要分两类，固定窗口的不固定窗口。
  - 固定窗口的题目，通常使用一个循环，枚举窗口即可。
  - 不固定窗口的题目，通常使用两个循环，外层循环枚举窗口的右边界，内层循环枚举窗口的左边界。外边界循环右移，当满足条件时，内边界**循环**右移，直到窗口**不再**满足条件，在这个过程中，更新结果。
- 当题目要求枚举所有满足某种条件的子数组/子串时，例如 **713.乘积小于 K 的子数组** ，题目要求找出所有乘积小于k的子数组，当我们使用滑动窗口时，我们找到是一个满足条件的数组，并且这个数组会包含很多元素（因为窗口是先扩大，再缩小，满足条件时停止缩小），此时这个数组的所有子数组都是一个满足条件的子数组，此时可以使用一个技巧。

  在向右移动的过程中，每向窗口中增加一个数num时(假设加上num后，数组的乘积小于k)，那么以num结尾的子数组，是right - left + 1个。实际上，我们也主需要关注以num结尾的子数组，因为在之前的遍历中，其他数组都已经被处理过了。